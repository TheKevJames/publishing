\documentclass[12pt]{article}
\usepackage{amsmath,amssymb,bookmark,parskip,custom}
\usepackage[margin=.8in]{geometry}
\allowdisplaybreaks
\hypersetup{colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
\setcounter{secnumdepth}{5}

\begin{document}

\title{CS 343 --- Concurrent and Parallel Programming}
\author{Kevin James}
\date{\vspace{-2ex}Fall 2015}
\maketitle\HRule

\tableofcontents
\newpage

\section{Exceptions}
Any contiguous code block can be factored into a helper routing and called from anywhere in the program. This process is called {\bf modularization}. Modularization can fail when the factored block exits (eg. with multi-level labelled exits) because labels are only scoped at function-level. To get around this, we can use global labels, ie:

\begin{verbatim}
label L;
void f() {
    // ...
    goto L;
}

void main() {
    L = L1;
    // ...
    f();
    // not exectuted
  L1:
    L = L2;
    // ...
    f();
    // not executed
  L2:
    return;
}
\end{verbatim}

Fundamentally, we can have routines with two types of returns:
\begin{description}
\item[normal returns] which skip to the statement after the call, and
\item[exceptional returns] which skip to statements \textit{not} after the call
\end{description}

Exceptional returns, though, can lead to the \code{goto} problem, ie. that you can jump anywhere and create spaghetti code.

\subsection{Traditional Approaches}
There are several more traditional approaches to this problem:
\begin{description}
\item[return codes] have return values which indicate normal or exceptional execution. These codes must be checked every time the function is called and mix normal return values with exceptional ones.
\item[status flags] set global variables indicating normal or exceptional execution. These values will be over-written by subsequent function calls and must be checked before this happens.
\item[fix-up routines] are passed into other routines; if a problem is detected, the fix-up routine returns a different result in place of the original function.
\end{description}

Note that we often combine these techniques.

\subsection{Exception Handling}
Compelx control-flow among routines is often called {\bf exception handling}. An exceptional event is one that is (usually) known to exists, but which is ancillary to the algorithm (eg. occurs with low frequency). An {\bf exception handling mechanism} (EHM) provides some alternate type of control flow.

The {\bf execution environment} has a significant effect on an EHM: eg. object-oriented environments require much more complex EHMs. Example: objects have destructores which must be executed no matter how the object ends, even if an exception is thrown.

Control structures with \code{finally} clauses must always be executed. This complicates the EHM, since now both destructors and \code{finally}s must be called. Given multiple execution stacks, an EHM must be even more sophisticated (eg. propogate the exception to another stack if no handler is found in the current one).

\subsection{Static and Dynamic Returns}
All routines and exceptional control flows can be characterized by the following properties:
\begin{description}
\item[static/dynamic call] routine/exectpion name at the call/raise is looked up statically (compile-time) or dynamically (run-time)
\item[static/dynamic return] after routine handler completes, it returns to its static (definition) or dynamic (call) context.
\end{description}

\begin{table}[ht]
\centering
\begin{tabular}{r|ll}
  return/handled & static  & dynamic \\ \hline
  static         & sequel  & termination exception \\
  dynamic        & routine & routine pointer, virtual routine, resumption \\ \hline
  \end{tabular}
\end{table}

\subsubsection{Static Propogation}
A {\bf sequel} is a routine with no return value where the sequel name is looked up lexically at the call site and control returns to the end of the block in which the sequel is declared. This is called {\bf static propogation}.

\begin{verbatim}
for(;;) {
    sequel f() { ... }
    // ...
    f();
    // not executed
}
// executed immediately after f();
\end{verbatim}

These are implemented in \code{try-catch}s. You can always determine statically what line a \code{catch} clause will execute when it returns: \code{catch}s are sequels.

\section{Terms}
\begin{description}
\item[execution] is the language unit in which an exception can be raised, usually any entity with its own runtime stack.
\item[exception type] is a type name representing an exceptional event.
\item[exception] is an instance of an exception type, generated by executing an operation indicating an ancillary (exceptional) situation in execution.
\item[raise (throw)] is the special operation that creates an exception.
\item[source execution] is the execution raising an exception.
\item[faulting execution] is the execution changing control flow due to a raised exception.
\item[local exception] is when an exception is raised and handled by the same execution: source = faulting.
\item[non-local exception] is when an exception is raised by a source execution but delivered to a different faulting execution: source $\neq$ faulting.
\item[concurrent exception] is a non-local exception, where the source and faulting executions are executing concurrently.
\item[propagation] directs control from a raise in the source execution to a handler in the faulting execution.
\item[propagation mechanism] is the rules used to locate a handler. The most common propagation-mechanisms give precedence to handlers higher in the lexical/call stack.
\begin{itemize}
\item specificity versus generality
\item efficient linear search during propagation
\end{itemize}
\item[handler] is inline (nested) routine responsible for handling raised exception.
\begin{enumerate}
\item handler catches exception by matching with one or more exception types.
\item after catching, a handler executes like a normal subroutine
\item handler can return, reraise the current exception, or raise a new exception
\item re-raise terminate current handling and continuing propagation of caught exception.
\begin{itemize}
\item useful if a handler cannot deal with an exception but needs to propagate same exception to handler further down the stack.
\item provided by a raise statement without an exception type (\code{throw;}) where a raise must be in progress.
\end{itemize}
\item an exception is handled only if the handler returns rather than reraises
\end{enumerate}
\item[guarded block] is a language block with associated handlers, e.g., try-block in C++/Java.
\item[unguarded block] is a block with no handlers.
\item[termination] means control cannot return to the raise point. All blocks on the faulting stack from the raise block to the guarded block handling the exception are terminated, called stack unwinding.
\item[resumption] means control returns to the raise point: no stack unwinding.
\item[EHM] = Exception Type + Raise (exception) + Propagation + Handlers
\end{description}

\end{document}
